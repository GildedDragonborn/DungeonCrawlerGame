import pygame
import random
import math
from typing import List, Tuple
from enemy import enemy
import os
import json
import array
from GameData.colorData import *

#TODO: this class acts as a single room that is generated by a random floor generator. Implement both


class room:
    def __init__(self, roomid: int, layer: int, x: int, y: int, enemies: bool, numEnemies: int, enemyVariant: int, visited: bool, roomVariant: str):
        self.__roomID = int(roomid)
        self.__layer = layer
        self.__variant = roomVariant
        self.__roomLayout = self.getRoom(roomid)
        self.__xCoord = x
        self.__yCoord = y
        self.__hostile: bool = enemies
        self.__numEnemies: int = numEnemies
        self.__enemyVariant: int = enemyVariant
        self.__enemies: List[enemy] = self.generateEnemies(enemyVariant) # x,y,Enemytype tuple((0, 0, None))
#        self.generateEnemies()
        if numEnemies >= len(self.__enemies):
            self.__numEnemies = len(self.__enemies)-1
        self.__visited: bool = visited

    @property
    def roomID(self) -> int:
        return self.__roomID

    @property
    def variant(self):
        return self.__variant

    @property
    def hostile(self) -> bool:
        return self.__hostile

    @property
    def getEnemies(self) -> list:
        return list(self.__enemies)

    @property
    def xCoord(self) -> int:
        return self.__xCoord

    @property
    def yCoord(self) -> int:
        return self.__yCoord

    @property
    def visited(self) -> bool:
        return self.__visited

    @property
    def numEnemies(self):
        return self.__numEnemies

    @property
    def enemyVariant(self):
        return self.__enemyVariant

    def removeEnemy(self, enemyIndex: int):
        """temp = []
        for i in range(len(self.__enemies)):
            if i != enemyIndex:
                temp.append(self.__enemies[i])
        self.__enemies = temp"""
        self.__enemies[enemyIndex] = None
        self.__numEnemies = self.__numEnemies - 1

    def decideVariant(self) -> str:
        temp = random.randint(0, 4)
        if temp == 0:
            var = "a"
        elif temp == 1:
            var = "b"
        elif temp == 2:
            var = "c"
        elif temp == 3:
            var = "d"
        elif temp == 4:
            var = "e"
        else:
            var = "a"
        return var

    def markVisited(self):
        self.__visited = True
        with open('GameData/currentFloor.json') as outFile:
            data = json.load(outFile)
            data["levelLayout"][self.__yCoord][self.__xCoord][4] = True
            data["roomLayout"][self.__yCoord][self.__xCoord] = self.__roomLayout

    def setEnemy(self, x: int, y: int, new: enemy):
        for i in self.__enemies:
            if i[0] == x or i[1] == y:
                return
        self.__enemies.append(tuple((x, y, new)))

    def getRoom(self, id: int = 0) -> array:
        with open('GameData/currentFloor.json') as inFile:
            data = json.load(inFile)
            if data["levelLayout"][self.__yCoord][self.__xCoord][4]:
                return data["roomLayout"][self.__yCoord][self.__xCoord]
            else:
                pass
        with open('GameData/roomData.json') as inFile:
            data = json.load(inFile)
            roomData = data[id]["rooms"][str(self.variant)]
            return roomData

    def getNextRoomHostile(self) -> bool:
        try:
            if random.randint(0,1) == 1:
                return True
            else:
                return False
        except IndexError:
            return False

    def getTile(self, x: int, y: int) -> int:
        return int(self.__roomLayout[y][x])

    def playerMoveCheck(self, x: int, y:int) -> bool:
        tileID: int = int(self.__roomLayout[y][x])
        return tileID == 0 or tileID == 3 or tileID == 6 or tileID == 8 or tileID == 10 or tileID == 12 or tileID == 17 or tileID == 18 or tileID == 99

    def generateEnemies(self, varID: int):
        temp = []
        with open('GameData/encounterPossibilities.json') as inFile:
            data = json.load(inFile)
            for i in data[varID]["enemies"]:
                temp.append(enemy(i))
        return temp 

    def setTile(self, x, y, newTile):
        self.__roomLayout[y][x] = newTile

    def drawRoom(self):
        width = 800
        height = 600
        screen = pygame.display.set_mode((width, height))
        screen.fill(background1)
        x = 0
        y = 0
        numEnemiesSpawned: int = 0
        """increment = width / 12
        while x <= width:
            start = [x, 0]
            end = [x, height]
            pygame.draw.line(screen, lineColor, start, end, width=2)
            x += increment
        while y <= height:
            start = [0, y]
            end = [width, y]
            pygame.draw.line(screen, lineColor, start, end, width=2)
            y += increment"""
        for i in range(12):
            for j in range(9):
                if self.__roomLayout[int(j)][int(i)] == 0:  # Empty Space
                    screen.blit(pygame.image.load(os.path.join("Assets", "tile.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 1:  # Door
                    pass
                elif self.__roomLayout[int(j)][int(i)] == 2:  # Rock
                    screen.blit(pygame.image.load(os.path.join("Assets", "tile.png")), (int(i) * 67, int(j) * 67))
                    screen.blit(pygame.image.load(os.path.join("Assets", "testRock.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 3: # Enemy (check enemy list)
                    screen.blit(pygame.image.load(os.path.join("Assets", "tile.png")), (int(i) * 67, int(j) * 67))
                    if self.hostile and len(self.__enemies) is not 0:
                        #self.generateEnemy(i,j)
                        #for x in self.__enemies:
                        print("ATTEMPTING TO SPAWN...")
                        if numEnemiesSpawned <= self.__numEnemies:
                            if self.__enemies[numEnemiesSpawned] is None:
                                pass #spawn remains sprite, no more enemy
                            elif self.__enemies[numEnemiesSpawned].name == "Cultist_Still" or self.__enemies[numEnemiesSpawned].name == "Cultist_Chase" or self.__enemies[numEnemiesSpawned].name == "Cultist_Patrol":
                                screen.blit(pygame.image.load(os.path.join("Assets", "cultistPlaceholder.png")), (int(i)*67, int(j)*67))
                                self.__enemies[numEnemiesSpawned].setX(i)
                                self.__enemies[numEnemiesSpawned].setY(j)
                                numEnemiesSpawned = numEnemiesSpawned + 1
                                print("SPAWNED CULTIST")
                            elif self.__enemies[numEnemiesSpawned].name == "Skeleton_Still" or self.__enemies[numEnemiesSpawned].name == "Skeleton_Chase" or self.__enemies[numEnemiesSpawned].name == "Skeleton_Patrol":
                                screen.blit(pygame.image.load(os.path.join("Assets", "skeletonEnemy.png")), (int(i)*67, int(j)*67))
                                self.__enemies[numEnemiesSpawned].setX(i)
                                self.__enemies[numEnemiesSpawned].setY(j)
                                numEnemiesSpawned = numEnemiesSpawned + 1
                                print("SPAWNED SKELETON")
                        else:
                            print ("FAILED: MAX ENEMIES REACHED")
                    else:
                        pass
                elif self.__roomLayout[int(j)][int(i)] == 4: # Hazard
                    pass
                elif self.__roomLayout[int(j)][int(i)] == 5:  # NorthWall
                    screen.blit(pygame.image.load(os.path.join("Assets", "NorthWall.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 6:  # NorthDoor
                    screen.blit(pygame.image.load(os.path.join("Assets", "NorthDoor.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 7:  # EastWall
                    screen.blit(pygame.image.load(os.path.join("Assets", "EastWall.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 8:  # EastDoor
                    screen.blit(pygame.image.load(os.path.join("Assets", "EastDoor.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 9:  # SouthWall
                    screen.blit(pygame.image.load(os.path.join("Assets", "SouthWall.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 10:  # SouthDoor
                    screen.blit(pygame.image.load(os.path.join("Assets", "SouthDoor.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 11:  # WestWall
                    screen.blit(pygame.image.load(os.path.join("Assets", "WestWall.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 12:  # WestDoor
                    screen.blit(pygame.image.load(os.path.join("Assets", "WestDoor.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 13:  # NWCorner
                    screen.blit(pygame.image.load(os.path.join("Assets", "NorthWestCorner.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 14:  # NECorner
                    screen.blit(pygame.image.load(os.path.join("Assets", "NorthEastCorner.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 15:  # SECorner
                    screen.blit(pygame.image.load(os.path.join("Assets", "SouthEastCorner.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 16:  # SWCorner
                    screen.blit(pygame.image.load(os.path.join("Assets", "SouthWestCorner.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 17: # NorthDoorR
                    screen.blit(pygame.image.load(os.path.join("Assets", "NorthDoorR.png")), (int(i)*67, int(j)*67))
                elif self.__roomLayout[int(j)][int(i)] == 18: # SouthDoorR
                    screen.blit(pygame.image.load(os.path.join("Assets", "SouthDoorR.png")), (int(i) * 67, int(j) * 67))
                elif self.__roomLayout[int(j)][int(i)] == 99: # Trapdoor
                    screen.blit(pygame.image.load(os.path.join("Assets", "trapDoor.png")), (int(i) * 67 -1, int(j) * 67))


        # use roomLayout to print out the room
        # 0 = blank
        # 1 = 4 doors empty
        # 2 = 3 doors (Up, Left, Down)
        # 3 = 2 doors (Up, Down)
        # 4 = 2 doors (Up, Left)
        # 5 = 2 doors (Down, Left)
        # 6 = End (Up)
        # 7 = End (Down)
        # 8 = End (Left)
        # 9 = 3 doors (Up, Right, Down)
        # 10 = 2 doors (Up, Right)
        # 11 = 2 doors (Down, Right)
        # 12 = End (Right)
        # 13 = 2 doors (Right, Left)
        # 14 = 3 doors (Right, Down, Left)
        # 15 = 3 doors (Right, Up, Left)
        # 16 = MinibossRoom
        # 17 = bossRoom
        # 18 = Shop
        # 19 = Item Room
        # 20 = Bank

    """def generateEnemy(self, x: int, y: int):
        if self.hostile:
            encounterNum = random.randint(0,1)
            if encounterNum == 0:
                self.setEnemy(x, y, enemy(0)) #still skeleton
            elif encounterNum == 1:
                self.setEnemy(x, y, enemy(4)) #still cultist
            else:
                pass
        else:
            return"""


    #Roomdata:
    #(int, bool, int, int, bool, char/str)
    #(roomID, isHostile, numEnemies, encounter #, isVisited, variation)
